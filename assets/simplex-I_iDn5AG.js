import{i as $}from"./umf-Bef8OHIG.js";import{E as g,r as P,p as x}from"./index-DFhyK2mv.js";function*R(n,t){function*o(i,c,a){if(c===n-1){yield[...a,i/t];return}for(let e=0;e<=i;e++)yield*o(i-e,c+1,[...a,e/t])}yield*o(t,0,[])}function b(n,t){return y(t+n-1,n-1)}function y(n,t){if(t>n)return 0;if(t===0||t===n)return 1;let o=1;for(let i=0;i<t;i++)o=o*(n-i)/(i+1);return Math.round(o)}function C(n,t){if(n.length!==t.length)throw new Error("Recipe count must match weight count");const o=t.reduce((e,r)=>e+r,0);if(Math.abs(o-1)>g)throw new Error(`Weights must sum to 1.0, got ${o}`);const i=new Map;for(let e=0;e<n.length;e++){const r=n[e],p=t[e];for(const u of r.ingredients){const m=i.get(u.material)||0;i.set(u.material,m+u.amount*p)}}const c=Array.from(i.entries()).filter(([e,r])=>r>g).map(([e,r])=>({material:e,amount:P(r,2),unit:"weight"})),a=n.map((e,r)=>{const p=Math.round(t[r]*100);return p===0?null:`${e.name.substring(0,1).toUpperCase()}${p}`}).filter(Boolean).join("-");return{id:`blend_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,name:`Blend: ${a}`,source:"calculated",ingredients:c,umf:null,coneRange:[Math.min(...n.map(e=>x(e.coneRange[0]))),Math.max(...n.map(e=>x(e.coneRange[1])))],atmosphere:n[0].atmosphere,surfaceType:"unknown",umfConfidence:"inferred",verified:!1}}function k(n,t){const{recipes:o,divisions:i,constraints:c}=n,a=[],e=[],r=[];if(o.length<2)return r.push("Need at least 2 recipes for simplex blend"),{value:null,confidence:"unknown",warnings:e,errors:r,trace:a};if(o.length!==t.length)return r.push("Recipe count must match UMF count"),{value:null,confidence:"unknown",warnings:e,errors:r,trace:a};if(i<1)return r.push("Divisions must be at least 1"),{value:null,confidence:"unknown",warnings:e,errors:r,trace:a};if(!t.every(l=>l!==null))return r.push("One or more input recipes has invalid UMF"),{value:null,confidence:"unknown",warnings:e,errors:r,trace:a};a.push({operation:"simplex_start",inputs:{recipeCount:o.length,divisions:i,expectedPoints:b(o.length,i)},output:0,note:`Starting ${S(o.length)} blend with ${i} divisions`});const u=[];let m=0;for(const l of R(o.length,i)){if(c){const{minPercentages:d,maxPercentages:h}=c;let f=!0;if(d){for(let s=0;s<l.length;s++)if(l[s]<(d[s]||0)){f=!1;break}}if(h){for(let s=0;s<l.length;s++)if(l[s]>(h[s]||1)){f=!1;break}}if(!f)continue}const w=C(o,l),v=$(t,l),M=l.map((d,h)=>{const f=Math.round(d*100);return f===0?null:`${o[h].name.substring(0,1).toUpperCase()}${f}`}).filter(Boolean).join("-");u.push({index:m,coordinates:l,recipe:w,umf:v,label:M}),m++}return a.push({operation:"simplex_complete",inputs:{expectedPoints:b(o.length,i)},output:u.length,note:`Generated ${u.length} blend points`}),{value:u,confidence:"inferred",warnings:e,errors:r,trace:a}}function S(n){return{2:"line",3:"triaxial",4:"quadaxial",5:"pentaxial",6:"hexaxial"}[n]||`${n}-axial`}export{b as a,k as s};

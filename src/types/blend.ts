/**
 * Blend Calculation Types
 * 
 * Five paradigms:
 * 1. SIMPLEX - Materials sum to 100% (line, triaxial, quadaxial, n-axial)
 * 2. GRID - Independent variables, unconstrained (biaxial, factorial)
 * 3. SPACE-FILLING - Systematic coverage (LHS, Sobol, Stull)
 * 4. OPTIMIZATION - Directed search toward a goal (Bayesian, etc)
 * 5. COORDINATE SYSTEM - How you represent the space (weight %, UMF, etc)
 */

import { GlazeRecipe } from './glaze'
import { UMF } from './umf'
import { Material } from './material'

/**
 * Blend paradigm type
 */
export type BlendParadigm = 
  | 'simplex'
  | 'grid'
  | 'space-filling'
  | 'optimization'

/**
 * Specific blend type within a paradigm
 */
export type BlendType =
  // Simplex
  | 'line'
  | 'triaxial'
  | 'quadaxial'
  | 'pentaxial'
  | 'n-simplex'
  // Grid
  | 'biaxial'
  | 'factorial'
  | 'radial'
  // Space-filling
  | 'lhs'          // Latin Hypercube Sampling
  | 'sobol'        // Sobol sequence
  | 'halton'       // Halton sequence
  // Optimization
  | 'bayesian'
  | 'genetic'

/**
 * A point generated by a simplex blend
 */
export interface SimplexPoint {
  index: number
  coordinates: number[]  // barycentric, sum to 1.0
  recipe: GlazeRecipe
  umf: UMF
  label?: string  // e.g., "A50-B30-C20"
}

/**
 * A point generated by a grid blend
 */
export interface GridPoint {
  index: number
  coordinates: number[]  // addition amounts
  recipe: GlazeRecipe
  umf: UMF
  label?: string
}

/**
 * An addition for grid blends
 */
export interface Addition {
  material: Material
  materialName: string
  min: number
  max: number
  steps: number
}

/**
 * Simplex blend configuration
 */
export interface SimplexBlendConfig {
  type: 'line' | 'triaxial' | 'quadaxial' | 'pentaxial' | 'n-simplex'
  recipes: GlazeRecipe[]
  divisions: number
  constraints?: SimplexConstraints
}

/**
 * Constraints for simplex blends
 */
export interface SimplexConstraints {
  minPercentages?: number[]  // minimum % for each corner
  maxPercentages?: number[]  // maximum % for each corner
}

/**
 * Grid blend configuration
 */
export interface GridBlendConfig {
  type: 'biaxial' | 'factorial' | 'radial'
  baseRecipe: GlazeRecipe
  additions: Addition[]
}

/**
 * Space-filling sample configuration
 */
export interface SpaceFillingSampleConfig {
  type: 'lhs' | 'sobol' | 'halton'
  bounds: Record<string, { min: number; max: number }>
  count: number
  seed?: number
}

/**
 * A space-filling sample point
 */
export interface SpaceFillingSample {
  index: number
  umf: UMF
  coordinates: Record<string, number>  // oxide -> value
  recipe?: GlazeRecipe  // synthesized if possible
}

/**
 * Complete blend result
 */
export interface BlendResult<T extends SimplexPoint | GridPoint | SpaceFillingSample> {
  paradigm: BlendParadigm
  type: BlendType
  points: T[]
  totalCount: number
  config: SimplexBlendConfig | GridBlendConfig | SpaceFillingSampleConfig
  generatedAt: string
}

/**
 * Point count utilities
 */
export const BlendPointCounts = {
  /**
   * Number of points in an n-simplex with k divisions
   * C(n + k - 1, k - 1) = (n + k - 1)! / (n! * (k - 1)!)
   */
  simplex: (materials: number, divisions: number): number => {
    const n = divisions
    const k = materials
    return binomial(n + k - 1, k - 1)
  },

  /**
   * Number of points in a grid with given step counts
   */
  grid: (steps: number[]): number => {
    return steps.reduce((a, b) => a * b, 1)
  },

  /**
   * Space-filling is just the requested count
   */
  spaceFilling: (count: number): number => count,
}

/**
 * Binomial coefficient helper
 */
function binomial(n: number, k: number): number {
  if (k > n) return 0
  if (k === 0 || k === n) return 1
  
  let result = 1
  for (let i = 0; i < k; i++) {
    result = result * (n - i) / (i + 1)
  }
  return Math.round(result)
}
